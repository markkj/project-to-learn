package terminal

import (
	"fmt"
	"os"
	"syscall"
	"unsafe"
)

type Terminal struct {
	// Termios
	/*
	   type Termios struct {
	       Iflag     uint64 // input modes
	       Oflag     uint64 // output modes
	       Cflag     uint64 // control modes
	       Lflag     uint64 // Local modes is generally control higher-level aspects of input processing than the input modes flags described in Input Modes, such as echoing, signals, and the choice of canonical or noncanonical input.
	       Cc        [20]uint8 // Special control character
	       Pad_cgo_0 [4]byte
	       Ispeed    uint64
	       Ospeed    uint64
	   }
	*/
	oldState        syscall.Termios
	cursorXPosition int64
	cursorYPosition int64
	isQuit          bool

	txtBuff []string
}

func NewTerminal() *Terminal {
	return &Terminal{
		cursorXPosition: 1,
		cursorYPosition: 1,
		// precap 1000 elements
		txtBuff: make([]string, 1, 1000),
	}
}

func (t *Terminal) enableRawMode() {
	// fd is a file descriptor, is for a file or other input / output resource (such as stdout terminal, file, etc)
	// ref: https://en.wikipedia.org/wiki/File_descriptor
	fd := uintptr(os.Stdin.Fd())
	/*
		can use os.Stdout.Fd() instead of os.Stdin.Fd(), but there are key differences in how they are used and their purpose.
		Hereâ€™s why:
		Terminal Settings (TIOCGETA):
		The terminal settings like TIOCGETA (used in syscall.Syscall for fetching terminal attributes) only apply to terminal input, which is typically associated with os.Stdin.
		os.Stdin.Fd() refers to the standard input stream, which is generally associated with reading from a terminal.
		os.Stdout.Fd() refers to the standard output stream, which is used for writing to the terminal.
		In other words, terminal attributes such as ECHO or ICANON (canonical mode) are about how input is read from the terminal, so they are typically manipulated using os.Stdin.Fd(). os.Stdout.Fd() will likely not be meaningful for these operations because it is for controlling the output, not input.
		Generated By ChatGPT
	*/
	var raw syscall.Termios
	// Syscall is function to direct access to os system calls.
	// Syscall(trap uintptr,a1 uintptr, a2 uintptr, a3 uintptr)
	// trap => system call operation number
	// a1,a2,a3 is arguments to pass to system call.
	// trap = SYS_IOCTL => is system call number for ioctl which stands for `I/O Control`
	// a1 = fd
	// a2 = TIOCGETA => gets the current terminal control settings of a device.
	// a3 = termios
	// retreiving terminal setting into raw
	if _, _, err := syscall.Syscall(syscall.SYS_IOCTL, fd, uintptr(syscall.TIOCGETA), uintptr(unsafe.Pointer(&raw))); err != 0 {
		fmt.Fprintln(os.Stderr, "Error getting terminal state:", err)
		os.Exit(1)
	}
	// set old state
	t.oldState = raw

	// ICRNL => this flag tell terminal to map carriage return (CR) characters to newline characters. '/r' (enter)
	// IXON => This is a flow control flag related to software flow control. It enables the terminal to handle XON/XOFF (software flow control) for pausing and resuming data transmission. Clearing this flag disables this flow control.
	// (still don't understand what tafak this flag mean)
	// ref: https://en.wikipedia.org/wiki/Pseudoterminal
	// this line we set Iflag to disabled ICRNL and IXON
	// ICRNL = 0b0100000000
	// IXON  = 0b1000000000
	// rawIflag (assume) =  (default) 1100000000 ^ (disabled by removed) 1100000000 = 0000000000
	raw.Iflag &^= syscall.ICRNL | syscall.IXON
	// ECHO => If this bit is set, echoing of input characters back to the terminal is enabled.
	// ICANON => This bit, if set, enables canonical input processing mode. Otherwise, input is processed in noncanonical mode. See Two Styles of Input: Canonical or Not.
	// ISIG => This bit controls whether the INTR, QUIT, and SUSP characters are recognized. The functions associated with these characters are performed if and only if this bit is set. Being in canonical or noncanonical input mode has no effect on the interpretation of these characters.
	// ref: https://www.gnu.org/software/libc/manual/html_node/Local-Modes.html
	raw.Lflag &^= syscall.ECHO | syscall.ICANON | syscall.ISIG
	/*
		Macro: int VMIN
		This is the subscript for the MIN slot in the c_cc array. Thus, termios.c_cc[VMIN] is the value itself.

		The MIN slot is only meaningful in noncanonical input mode; it specifies the minimum number of bytes that must be available in the input queue in order for read to return.

		Macro: int VTIME
		This is the subscript for the TIME slot in the c_cc array. Thus, termios.c_cc[VTIME] is the value itself.

		The TIME slot is only meaningful in noncanonical input mode; it specifies how long to wait for input before returning, in units of 0.1 seconds.
		ref: https://www.gnu.org/software/libc/manual/html_node/Noncanonical-Input.html
	*/
	raw.Cc[syscall.VMIN] = 1
	raw.Cc[syscall.VTIME] = 0

	// TIOCSETA => make the change immediately
	if _, _, err := syscall.Syscall(syscall.SYS_IOCTL, fd, uintptr(syscall.TIOCSETA), uintptr(unsafe.Pointer(&raw))); err != 0 {
		fmt.Fprintln(os.Stderr, "Error setting terminal state:", err)
		os.Exit(1)
	}
}

func (t *Terminal) disableRawMode() {
	fd := os.Stdin.Fd()
	if _, _, err := syscall.Syscall(syscall.SYS_IOCTL, fd, uintptr(syscall.TIOCSETA), uintptr(unsafe.Pointer(&t.oldState))); err != 0 {
		fmt.Fprintln(os.Stderr, "Error restoring terminal state:", err)
		os.Exit(1)
	}
}

func (t *Terminal) printTextBuffer() {
	for row, line := range t.txtBuff {
		// Move cursor to the beginning of each line (columns are 1-indexed).
		// Print value to correct cursor position in terminal
		fmt.Printf("\x1b[%d;1H%s", row+1, line)
	}
}

func (t *Terminal) refreshScreen() {
	t.clearScreen()
	t.printTextBuffer()
	// moveCursor uses ANSI escape codes to position the cursor.
	// (x,y) here are 0-indexed, so we add 1 for the ANSI code.
	fmt.Printf("\x1b[%d;%dH", t.cursorYPosition, t.cursorXPosition)
	os.Stdout.Sync()
}

func (t *Terminal) clearScreen() {
	// ANSI escape code to clear screen.
	fmt.Print("\x1b[2J")
}

func (t *Terminal) relp() error {
	for {
		t.refreshScreen()
		if err := t.eval(); err != nil {
			return err
		}
		if t.isQuit {
			return nil
		}
	}
}

func (t *Terminal) eval() error {
	keyEvent, err := ParseKeyEvent()
	if err != nil {
		return err
	}

	switch keyEvent.KeyCode {
	case KeyChar:
		if len(t.txtBuff) < int(t.cursorYPosition) {
			t.txtBuff = append(t.txtBuff, "")
		}
		line := t.txtBuff[t.cursorYPosition-1]
		t.txtBuff[t.cursorYPosition-1] = line[:t.cursorXPosition-1] + string(keyEvent.Char) + line[t.cursorXPosition-1:]
		t.cursorXPosition += 1
	case KeyBackSpace:
		if t.cursorXPosition-1 >= 1 {
			line := t.txtBuff[t.cursorYPosition-1]
			t.txtBuff[t.cursorYPosition-1] = line[:t.cursorXPosition-2] + line[t.cursorXPosition-1:]
			t.cursorXPosition -= 1
		}
	case KeyEnter:
		t.cursorYPosition += 1
		if len(t.txtBuff) < int(t.cursorYPosition) {
			t.txtBuff = append(t.txtBuff, "")
		}
		t.cursorXPosition = 1
	case KeyEsc:
		t.isQuit = true
	case KeyArrowLeft:
		if t.cursorXPosition > 1 {
			t.cursorXPosition -= 1
		}
	case KeyArrowRight:
		if len(t.txtBuff[t.cursorYPosition-1]) >= int(t.cursorXPosition) {
			t.cursorXPosition += 1
		}
	case KeyArrowUp:
		if int(t.cursorYPosition) > 1 {
			t.cursorYPosition -= 1
			if int(t.cursorXPosition) > len(t.txtBuff[t.cursorYPosition-1]) {
				t.cursorXPosition = int64(len(t.txtBuff[t.cursorYPosition-1])) + 1
			}
		}
	case KeyArrowDown:
		if len(t.txtBuff) > int(t.cursorYPosition) {
			t.cursorYPosition += 1
			if int(t.cursorXPosition) > len(t.txtBuff[t.cursorYPosition-1]) {
				t.cursorXPosition = int64(len(t.txtBuff[t.cursorYPosition-1])) + 1
			}
		}
	}
	return nil
}

func (t *Terminal) Run() {
	t.enableRawMode()
	defer t.disableRawMode()

	if err := t.relp(); err != nil {
		panic(err)
	}
}
